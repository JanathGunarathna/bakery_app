import React, { useState, useEffect, useCallback, useMemo } from "react";
import { firestore } from "../firebase";
import { addDoc, collection, getDocs, query, orderBy, doc, updateDoc, deleteDoc } from "firebase/firestore";

const SHOPS = ["Shop A", "Shop B", "Shop C", "Shop D"];
const BAKERY_ITEMS = [
  "Normal bread", "Sandwich bread", "Half bread", "1/2 rose bread", "1/4 rose bread",
  "Tea bun", "Dagara bun", "Dot bun", "Cream bun", "Viyana Roll", "Jam bun",
  "Fish bun", "Sinisambol bun", "Othana Sausages", "Vegetable Bun", "Fish pastry",
  "Egg Pastry", "Sausages Pastry", "Fish Roll", "Egg Roll", "Vegetable Rotty",
  "Fish Rotty", "Chicken Pastry", "Wade", "patty -Vegetable", "Patty -fish",
  "Egg Bun", "Sausages Bun", "Hot dog", "Burger -Chicken", "Burger -Egg Bullseye",
  "Devel Sausages", "Omlet Bun", "Umbalakada Bun", "Semon Bun", "Fish finger",
  "Drumstick -Chicken", "Fish Cake", "Egg Pizza", "Sausages Pizza -cheese",
  "Sandwich -Egg", "Sandwich -fish", "Sandwich -Cheese", "string Hoppers",
  "Helapa", "Levaria", "Spanchi -Vanila", "Spanchi -Chocolate", "Cup Cake",
  "Daughnut", "Rock Bun", "Gnanakatha", "Pol Cake", "Swiss Roll", "Butter Cake",
  "100 Baby crush", "1/4 Side Rosed", "1/2 Side Rosed"
];

export default function SelectionPage() {
  // State management
  const [inventoryData, setInventoryData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);
  const [editingCells, setEditingCells] = useState(new Set());
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [bakeryItems, setBakeryItems] = useState([...BAKERY_ITEMS]);
  
  // Filter states
  const [filters, setFilters] = useState({
    shop: SHOPS[0], // Default to first shop
    date: new Date().toISOString().split('T')[0], // Default to today
  });
  
  // UI state
  const [showNewItemForm, setShowNewItemForm] = useState(false);
  const [newItemName, setNewItemName] = useState("");
  
  // Firestore collection reference
  const inventoryRef = collection(firestore, "inventory");
  
  // Fetch inventory data from Firestore
  const fetchInventoryData = useCallback(async () => {
    try {
      setLoading(true);
      const q = query(inventoryRef, orderBy("createdAt", "desc"));
      const querySnapshot = await getDocs(q);
      
      const data = querySnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      
      setInventoryData(data);
    } catch (error) {
      console.error("Error fetching inventory data:", error);
      
      // Fallback without ordering
      try {
        const querySnapshot = await getDocs(inventoryRef);
        const data = querySnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
        
        // Manual sort by createdAt
        data.sort((a, b) => {
          const dateA = new Date(a.createdAt || 0);
          const dateB = new Date(b.createdAt || 0);
          return dateB - dateA;
        });
        setInventoryData(data);
      } catch (fallbackError) {
        console.error("Fallback fetch failed:", fallbackError);
        setInventoryData([]);
      }
    } finally {
      setLoading(false);
    }
  }, []);
  
  // Load data on component mount
  useEffect(() => {
    fetchInventoryData();
  }, [fetchInventoryData]);
  
  // Get previous day remaining inventory for an item
  const getPreviousDayRemaining = useCallback((itemName, shop, currentDate) => {
    if (!itemName || !shop || !currentDate) return 0;
    
    const currentDateObj = new Date(currentDate);
    const previousDate = new Date(currentDateObj);
    previousDate.setDate(previousDate.getDate() - 1);
    const previousDateStr = previousDate.toISOString().split('T')[0];
    
    const previousDayData = inventoryData.find(item => 
      item.itemName === itemName && 
      item.shop === shop && 
      item.date === previousDateStr
    );
    
    return previousDayData ? (previousDayData.remainingInventory || 0) : 0;
  }, [inventoryData]);
  
  // Create complete table data with all items
  const completeTableData = useMemo(() => {
    const { shop, date } = filters;
    if (!shop || !date) return [];
    
    return bakeryItems.map(itemName => {
      // Find existing data for this item, shop, and date
      const existingData = inventoryData.find(item => 
        item.itemName === itemName && 
        item.shop === shop && 
        item.date === date
      );
      
      const previousDayRemaining = getPreviousDayRemaining(itemName, shop, date);
      const addedInventory = existingData ? (existingData.addedInventory || 0) : 0;
      const startingInventory = previousDayRemaining + addedInventory;
      const selling = existingData ? (existingData.selling || 0) : 0;
      const remainingInventory = startingInventory - selling;
      
      return {
        id: existingData?.id || `${shop}_${date}_${itemName}`,
        itemName,
        shop,
        date,
        previousDayRemaining,
        addedInventory,
        startingInventory,
        selling,
        remainingInventory,
        isExisting: !!existingData,
        originalData: existingData
      };
    });
  }, [bakeryItems, inventoryData, filters, getPreviousDayRemaining]);
  
  // Handle filter changes
  const handleFilterChange = useCallback((field, value) => {
    setFilters(prev => ({
      ...prev,
      [field]: value
    }));
  }, []);
  
  // Handle cell edit
  const handleCellEdit = useCallback((itemId, field, value) => {
    const cellKey = `${itemId}_${field}`;
    
    // Update the inventory data
    setInventoryData(prevData => {
      const existingItemIndex = prevData.findIndex(item => item.id === itemId);
      
      if (existingItemIndex >= 0) {
        // Update existing item
        const updatedData = [...prevData];
        const updatedItem = { ...updatedData[existingItemIndex] };
        
        if (field === 'addedInventory') {
          const addedInventory = parseInt(value) || 0;
          const previousDayRemaining = getPreviousDayRemaining(updatedItem.itemName, updatedItem.shop, updatedItem.date);
          updatedItem.addedInventory = addedInventory;
          updatedItem.startingInventory = previousDayRemaining + addedInventory;
          updatedItem.remainingInventory = updatedItem.startingInventory - (updatedItem.selling || 0);
        } else if (field === 'selling') {
          const selling = parseInt(value) || 0;
          updatedItem.selling = selling;
          updatedItem.remainingInventory = (updatedItem.startingInventory || 0) - selling;
        }
        
        updatedData[existingItemIndex] = updatedItem;
        return updatedData;
      } else {
        // Create new item for items that don't exist in database yet
        const [shop, date, itemName] = itemId.split('_');
        const previousDayRemaining = getPreviousDayRemaining(itemName, shop, date);
        
        const newItem = {
          id: itemId,
          itemName,
          shop,
          date,
          previousDayRemaining,
          addedInventory: field === 'addedInventory' ? (parseInt(value) || 0) : 0,
          selling: field === 'selling' ? (parseInt(value) || 0) : 0,
          createdAt: new Date().toISOString(),
        };
        
        newItem.startingInventory = newItem.previousDayRemaining + newItem.addedInventory;
        newItem.remainingInventory = newItem.startingInventory - newItem.selling;
        
        return [...prevData, newItem];
      }
    });
    
    // Mark cell as edited
    setEditingCells(prev => new Set([...prev, cellKey]));
    setHasUnsavedChanges(true);
  }, [getPreviousDayRemaining]);
  
  // Save changes to Firebase
  const handleSaveChanges = useCallback(async () => {
    try {
      setSubmitting(true);
      
      const updatedItems = completeTableData.filter(item => {
        const addedCellKey = `${item.id}_addedInventory`;
        const sellingCellKey = `${item.id}_selling`;
        return editingCells.has(addedCellKey) || editingCells.has(sellingCellKey);
      });
      
      const savePromises = updatedItems.map(async (item) => {
        if (item.isExisting && item.originalData) {
          // Update existing document
          const docRef = doc(firestore, "inventory", item.originalData.id);
          await updateDoc(docRef, {
            addedInventory: item.addedInventory,
            startingInventory: item.startingInventory,
            selling: item.selling,
            remainingInventory: item.remainingInventory,
            updatedAt: new Date().toISOString()
          });
        } else if (item.addedInventory > 0 || item.selling > 0) {
          // Create new document only if there's actual data
          await addDoc(inventoryRef, {
            date: item.date,
            shop: item.shop,
            itemName: item.itemName,
            previousDayRemaining: item.previousDayRemaining,
            addedInventory: item.addedInventory,
            startingInventory: item.startingInventory,
            selling: item.selling,
            remainingInventory: item.remainingInventory,
            createdAt: new Date().toISOString(),
          });
        }
      });
      
      await Promise.all(savePromises);
      
      setEditingCells(new Set());
      setHasUnsavedChanges(false);
      await fetchInventoryData();
      
      alert("Changes saved successfully!");
    } catch (error) {
      console.error("Error saving changes:", error);
      alert("Failed to save changes. Please try again.");
    } finally {
      setSubmitting(false);
    }
  }, [completeTableData, editingCells, fetchInventoryData]);
  
  // Add new bakery item
  const handleAddNewItem = useCallback(() => {
    if (newItemName.trim() && !bakeryItems.includes(newItemName.trim())) {
      setBakeryItems(prev => [...prev, newItemName.trim()]);
      setNewItemName("");
      setShowNewItemForm(false);
      alert("New item added successfully!");
    } else if (bakeryItems.includes(newItemName.trim())) {
      alert("This item already exists!");
    } else {
      alert("Please enter a valid item name.");
    }
  }, [newItemName, bakeryItems]);
  
  // Navigate to different date
  const navigateDate = useCallback((days) => {
    const currentDate = new Date(filters.date);
    const newDate = new Date(currentDate);
    newDate.setDate(newDate.getDate() + days);
    handleFilterChange('date', newDate.toISOString().split('T')[0]);
  }, [filters.date, handleFilterChange]);
  
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-100">
      <div className="container mx-auto px-4 py-6 max-w-full">
        {/* Header */}
        <header className="text-center mb-8">
          <h1 className="text-4xl md:text-5xl font-bold bg-gradient-to-r from-blue-600 to-indigo-600 bg-clip-text text-transparent mb-3">
            T & S Bakery Inventory
          </h1>
          <p className="text-slate-600 text-lg">Complete daily inventory tracking for all bakery items</p>
        </header>

        {/* Filters Section */}
        <section className="bg-white/80 backdrop-blur-sm rounded-xl shadow-lg border border-white/20 p-6 mb-6">
          <h2 className="text-lg font-semibold text-slate-800 mb-4 flex items-center gap-2">
            🔍 Select Shop & Date
          </h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
            <div>
              <label htmlFor="shop-filter" className="block text-sm font-medium text-slate-700 mb-2">
                Select Shop:
              </label>
              <select 
                id="shop-filter"
                value={filters.shop} 
                onChange={(e) => handleFilterChange('shop', e.target.value)}
                className="w-full bg-white border border-slate-300 rounded-lg px-3 py-2.5 text-slate-700 focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200"
              >
                {SHOPS.map((shop) => (
                  <option key={shop} value={shop}>{shop}</option>
                ))}
              </select>
            </div>
            
            <div>
              <label htmlFor="date-filter" className="block text-sm font-medium text-slate-700 mb-2">
                Select Date:
              </label>
              <div className="flex gap-2">
                <button
                  onClick={() => navigateDate(-1)}
                  className="px-3 py-2.5 bg-slate-200 hover:bg-slate-300 rounded-lg text-slate-700 transition-colors"
                  title="Previous day"
                >
                  ←
                </button>
                <input
                  id="date-filter"
                  type="date"
                  value={filters.date}
                  onChange={(e) => handleFilterChange('date', e.target.value)}
                  className="flex-1 bg-white border border-slate-300 rounded-lg px-3 py-2.5 text-slate-700 focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all duration-200"
                />
                <button
                  onClick={() => navigateDate(1)}
                  className="px-3 py-2.5 bg-slate-200 hover:bg-slate-300 rounded-lg text-slate-700 transition-colors"
                  title="Next day"
                >
                  →
                </button>
              </div>
            </div>
            
            <div className="flex gap-2">
              <button
                onClick={() => handleFilterChange('date', new Date().toISOString().split('T')[0])}
                className="px-4 py-2.5 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors text-sm"
              >
                Today
              </button>
              {hasUnsavedChanges && (
                <button
                  onClick={handleSaveChanges}
                  disabled={submitting}
                  className="bg-gradient-to-r from-green-500 to-emerald-500 text-white px-4 py-2.5 rounded-lg hover:shadow-lg transition-all duration-200 font-medium disabled:opacity-50 text-sm"
                >
                  {submitting ? "Saving..." : "Save Changes"}
                </button>
              )}
            </div>
          </div>
        </section>

        {/* Add New Item Section */}
        <section className="bg-white/80 backdrop-blur-sm rounded-xl shadow-lg border border-white/20 p-6 mb-6">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-lg font-semibold text-slate-800 flex items-center gap-2">
              ➕ Manage Items
            </h2>
            <button
              onClick={() => setShowNewItemForm(!showNewItemForm)}
              className="bg-gradient-to-r from-emerald-500 to-teal-500 text-white px-4 py-2 rounded-lg hover:shadow-lg transition-all duration-200 text-sm"
            >
              {showNewItemForm ? "Cancel" : "Add New Item"}
            </button>
          </div>
          
          {showNewItemForm && (
            <div className="flex gap-2 items-end">
              <div className="flex-1">
                <label className="block text-sm font-medium text-slate-700 mb-2">
                  New Item Name:
                </label>
                <input
                  type="text"
                  value={newItemName}
                  onChange={(e) => setNewItemName(e.target.value)}
                  placeholder="Enter new bakery item name"
                  className="w-full bg-white border border-slate-300 rounded-lg px-3 py-2.5 focus:ring-2 focus:ring-emerald-500 focus:border-transparent"
                />
              </div>
              <button
                onClick={handleAddNewItem}
                className="px-4 py-2.5 bg-emerald-600 text-white rounded-lg hover:bg-emerald-700 transition-colors"
              >
                Add Item
              </button>
            </div>
          )}
        </section>

        {/* Inventory Table Section */}
        <section className="bg-white/90 backdrop-blur-sm rounded-xl shadow-xl border border-white/20 overflow-hidden">
          <div className="p-6 border-b border-slate-200">
            <h2 className="text-xl font-semibold text-slate-800 flex items-center gap-2">
              📊 Daily Inventory - {filters.shop} - {filters.date}
            </h2>
            <p className="text-slate-600 text-sm mt-1">
              Complete inventory view for all {bakeryItems.length} bakery items
            </p>
          </div>
          
          <div className="overflow-x-auto">
            <table className="w-full">
              <thead className="bg-slate-50 sticky top-0">
                <tr>
                  <th className="px-4 py-4 text-left text-sm font-semibold text-slate-700 min-w-[200px]">
                    Item Name
                  </th>
                  <th className="px-4 py-4 text-center text-sm font-semibold text-slate-700 min-w-[120px]">
                    Previous Day<br/>Remaining
                  </th>
                  <th className="px-4 py-4 text-center text-sm font-semibold text-slate-700 min-w-[120px]">
                    Added<br/>Inventory
                  </th>
                  <th className="px-4 py-4 text-center text-sm font-semibold text-slate-700 min-w-[120px]">
                    Starting<br/>Total
                  </th>
                  <th className="px-4 py-4 text-center text-sm font-semibold text-slate-700 min-w-[120px]">
                    Items<br/>Sold
                  </th>
                  <th className="px-4 py-4 text-center text-sm font-semibold text-slate-700 min-w-[120px]">
                    Remaining<br/>Inventory
                  </th>
                </tr>
              </thead>
              <tbody className="divide-y divide-slate-200">
                {loading ? (
                  <tr>
                    <td colSpan="6" className="px-6 py-12 text-center">
                      <div className="flex flex-col items-center">
                        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mb-4"></div>
                        <p className="text-slate-500 text-lg font-medium">Loading inventory data...</p>
                      </div>
                    </td>
                  </tr>
                ) : (
                  completeTableData.map((row, index) => {
                    const hasData = row.addedInventory > 0 || row.selling > 0;
                    const isEdited = editingCells.has(`${row.id}_addedInventory`) || editingCells.has(`${row.id}_selling`);
                    
                    return (
                      <tr 
                        key={row.id} 
                        className={`transition-colors duration-150 ${
                          hasData ? 'bg-blue-50/50 hover:bg-blue-100/50' : 'hover:bg-slate-50'
                        } ${isEdited ? 'bg-yellow-50 border-yellow-200' : ''}`}
                      >
                        <td className="px-4 py-3 text-sm font-medium text-slate-800">
                          <div className="flex items-center gap-2">
                            <span className={`w-2 h-2 rounded-full ${hasData ? 'bg-blue-500' : 'bg-slate-300'}`}></span>
                            <span title={row.itemName} className="truncate">
                              {row.itemName}
                            </span>
                          </div>
                        </td>
                        
                        <td className="px-4 py-3 text-sm text-center">
                          <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                            {row.previousDayRemaining}
                          </span>
                        </td>
                        
                        <td className="px-4 py-3 text-sm text-center">
                          <input
                            type="number"
                            value={row.addedInventory}
                            onChange={(e) => handleCellEdit(row.id, 'addedInventory', e.target.value)}
                            className={`w-20 text-center border rounded px-2 py-1 text-xs focus:ring-2 focus:ring-blue-500 focus:border-transparent ${
                              editingCells.has(`${row.id}_addedInventory`) 
                                ? 'border-yellow-400 bg-yellow-50' 
                                : 'border-slate-300'
                            }`}
                            min="0"
                            placeholder="0"
                          />
                        </td>
                        
                        <td className="px-4 py-3 text-sm text-center">
                          <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
                            {row.startingInventory}
                          </span>
                        </td>
                        
                        <td className="px-4 py-3 text-sm text-center">
                          <input
                            type="number"
                            value={row.selling}
                            onChange={(e) => handleCellEdit(row.id, 'selling', e.target.value)}
                            className={`w-20 text-center border rounded px-2 py-1 text-xs focus:ring-2 focus:ring-blue-500 focus:border-transparent ${
                              editingCells.has(`${row.id}_selling`) 
                                ? 'border-yellow-400 bg-yellow-50' 
                                : 'border-slate-300'
                            }`}
                            min="0"
                            max={row.startingInventory}
                            placeholder="0"
                          />
                        </td>
                        
                        <td className="px-4 py-3 text-sm text-center">
                          <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                            row.remainingInventory > 0 ? 'bg-emerald-100 text-emerald-800' : 
                            row.remainingInventory === 0 ? 'bg-yellow-100 text-yellow-800' :
                            'bg-red-100 text-red-800'
                          }`}>
                            {row.remainingInventory}
                          </span>
                        </td>
                      </tr>
                    );
                  })
                )}
              </tbody>
            </table>
          </div>
        </section>

        {/* Summary Section */}
        <section className="bg-white/80 backdrop-blur-sm rounded-xl shadow-lg border border-white/20 p-6 mt-6">
          <h2 className="text-lg font-semibold text-slate-800 mb-4 flex items-center gap-2">
            📈 Daily Summary
          </h2>
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div className="text-center p-4 bg-blue-50 rounded-lg">
              <div className="text-2xl font-bold text-blue-600">
                {completeTableData.reduce((sum, item) => sum + item.addedInventory, 0)}
              </div>
              <div className="text-sm text-blue-700">Total Added</div>
            </div>
            <div className="text-center p-4 bg-purple-50 rounded-lg">
              <div className="text-2xl font-bold text-purple-600">
                {completeTableData.reduce((sum, item) => sum + item.startingInventory, 0)}
              </div>
              <div className="text-sm text-purple-700">Total Starting</div>
            </div>
            <div className="text-center p-4 bg-orange-50 rounded-lg">
              <div className="text-2xl font-bold text-orange-600">
                {completeTableData.reduce((sum, item) => sum + item.selling, 0)}
              </div>
              <div className="text-sm text-orange-700">Total Sold</div>
            </div>
            <div className="text-center p-4 bg-emerald-50 rounded-lg">
              <div className="text-2xl font-bold text-emerald-600">
                {completeTableData.reduce((sum, item) => sum + item.remainingInventory, 0)}
              </div>
              <div className="text-sm text-emerald-700">Total Remaining</div>
            </div>
          </div>
        </section>
      </div>
    </div>
  );
}
